<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `glium` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, glium">

    <title>glium - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>glium</a><wbr><a class='stability Unstable' title=''>Unstable</a></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/glium/lib.rs.html#1-1504'>[src]</a></span></h1>
<div class='docblock'><p>Easy-to-use high-level OpenGL3+ wrapper.</p>

<h1 id="initialization" class='section-header'><a
                           href="#initialization">Initialization</a></h1>
<p>This library defines the <code>DisplayBuild</code> trait which is curently implemented only on
<code>glutin::WindowBuilder</code>.</p>

<p>Initialization is done by creating a <code>WindowBuilder</code> and calling <code>build_glium</code>.</p>
<pre class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>glutin</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>glium</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>glium</span>::<span class='ident'>DisplayBuild</span>;

    <span class='kw'>let</span> <span class='ident'>display</span> <span class='op'>=</span> <span class='ident'>glutin</span>::<span class='ident'>WindowBuilder</span>::<span class='ident'>new</span>()
        .<span class='ident'>with_dimensions</span>(<span class='number'>1024</span>, <span class='number'>768</span>)
        .<span class='ident'>with_title</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello world&quot;</span>))
        .<span class='ident'>build_glium</span>().<span class='ident'>unwrap</span>();
}
</pre>

<p>The <code>display</code> object is the most important object of this library.</p>

<p>The window where you are drawing on will produce events. They can be received by calling
<code>display.poll_events()</code>.</p>

<h2 id="complete-example" class='section-header'><a
                           href="#complete-example">Complete example</a></h2>
<p>We start by creating the vertex buffer, which contains the list of all the points that are part
of our mesh. The elements that we pass to <code>VertexBuffer::new</code> must implement the
<code>glium::vertex_buffer::VertexFormat</code> trait. We can easily do this by creating a custom struct
and adding the <code>#[vertex_format]</code> attribute to it.</p>

<p>You can check the documentation of the <code>vertex_buffer</code> module for more informations.</p>
<pre class='rust '>
<span class='attribute'>#[<span class='ident'>plugin</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>glium_macros</span>;

<span class='attribute'>#[<span class='ident'>vertex_format</span>]</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Vertex</span> {
    <span class='ident'>position</span>: [<span class='ident'>f32</span>; <span class='number'>2</span>],
    <span class='ident'>color</span>: [<span class='ident'>f32</span>; <span class='number'>3</span>],
}

<span class='kw'>let</span> <span class='ident'>vertex_buffer</span> <span class='op'>=</span> <span class='ident'>glium</span>::<span class='ident'>VertexBuffer</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>display</span>, <span class='macro'>vec</span><span class='macro'>!</span>[
    <span class='ident'>Vertex</span> { <span class='ident'>position</span>: [<span class='op'>-</span><span class='number'>0.5</span>, <span class='op'>-</span><span class='number'>0.5</span>], <span class='ident'>color</span>: [<span class='number'>0.0</span>, <span class='number'>1.0</span>, <span class='number'>0.0</span>] },
    <span class='ident'>Vertex</span> { <span class='ident'>position</span>: [ <span class='number'>0.0</span>,  <span class='number'>0.5</span>], <span class='ident'>color</span>: [<span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>1.0</span>] },
    <span class='ident'>Vertex</span> { <span class='ident'>position</span>: [ <span class='number'>0.5</span>, <span class='op'>-</span><span class='number'>0.5</span>], <span class='ident'>color</span>: [<span class='number'>1.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span>] },
]);
</pre>

<p>Then we create the index buffer, which contains informations about the primitives (triangles,
lines, etc.) that compose our mesh.</p>

<p>The last parameter is a list of indices that represent the positions of our points in the
vertex buffer.</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>index_buffer</span> <span class='op'>=</span> <span class='ident'>glium</span>::<span class='ident'>IndexBuffer</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>display</span>,
    <span class='ident'>glium</span>::<span class='ident'>index_buffer</span>::<span class='ident'>TrianglesList</span>(<span class='macro'>vec</span><span class='macro'>!</span>[ <span class='number'>0u16</span>, <span class='number'>1</span>, <span class='number'>2</span> ]));
</pre>

<p>Then we create the program, which is composed of a <em>vertex shader</em>, a program executed once for
each element in our vertex buffer, and a <em>fragment shader</em>, a program executed once for each
pixel before it is written on the final image.</p>

<p>The purpose of a program is to instruct the GPU how to process our mesh in order to obtain pixels.</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='ident'>glium</span>::<span class='ident'>Program</span>::<span class='ident'>from_source</span>(<span class='kw-2'>&amp;</span><span class='ident'>display</span>,
    <span class='comment'>// vertex shader</span>
    <span class='string'>&quot;   #version 110

        uniform mat4 matrix;

        attribute vec2 position;
        attribute vec3 color;

        varying vec3 v_color;

        void main() {
            gl_Position = vec4(position, 0.0, 1.0) * matrix;
            v_color = color;
        }
    &quot;</span>,

    <span class='comment'>// fragment shader</span>
    <span class='string'>&quot;   #version 110
        varying vec3 v_color;

        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
    &quot;</span>,

    <span class='comment'>// optional geometry shader</span>
    <span class='prelude-val'>None</span>
).<span class='ident'>unwrap</span>();
</pre>

<p><em>Note: Teaching you the GLSL language is not covered by this guide.</em></p>

<p>You may notice that the <code>attribute</code> declarations in the vertex shader match the field names and
types of the elements in the vertex buffer. This is required, or drawing will result in an error.</p>

<p>In the example above, you may notice <code>uniform mat4 matrix;</code>. This is a <em>uniform</em>, in other words
a global variable in our program. We will need to tell glium what the value of <code>matrix</code> is by
creating an object that implements the <code>glium::uniforms::Uniforms</code> trait.</p>

<p>Similarly to the vertex buffer and vertex format, we can do so by creating a custom struct  and
adding the <code>#[uniforms]</code> attribute to it.</p>
<pre class='rust '>
<span class='attribute'>#[<span class='ident'>plugin</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>glium_macros</span>;

<span class='attribute'>#[<span class='ident'>uniforms</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Uniforms</span> {
    <span class='ident'>matrix</span>: [[<span class='ident'>f32</span>; <span class='number'>4</span>]; <span class='number'>4</span>],
}

<span class='kw'>let</span> <span class='ident'>uniforms</span> <span class='op'>=</span> <span class='ident'>Uniforms</span> {
    <span class='ident'>matrix</span>: [
        [ <span class='number'>1.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span> ],
        [ <span class='number'>0.0</span>, <span class='number'>1.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span> ],
        [ <span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>1.0</span>, <span class='number'>0.0</span> ],
        [ <span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>1.0</span> ]
    ],
};
</pre>

<p>Vertex buffers, index buffers and program should be stored between draws in order to avoid wasting
time, but objects that implement the <code>glium::uniforms::Uniforms</code> trait are usually constructed
every time you draw.</p>

<p>Fields of our <code>Uniforms</code> object can be any object that implements <code>glium::uniforms::UniformValue</code>.
This includes textures and samplers (not covered here). You can check the documentation of the
<code>uniforms</code> module for more informations.</p>

<p>Now that everything is initialized, we can finally draw something. To do so, call <code>display.draw()</code>
in order to obtain a <code>Frame</code> object. Note that it is also possible to draw on a texture by
calling <code>texture.as_surface()</code>, but this is not covered here.</p>

<p>The <code>Frame</code> object has a <code>draw</code> function which you can use to draw things.
Its arguments are the vertex buffer, index buffer, program, uniforms, and an object of type
<code>DrawParameters</code> which contains miscellaneous informations about how everything should be rendered
(depth test, blending, backface culling, etc.).</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>glium</span>::<span class='ident'>Surface</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>target</span> <span class='op'>=</span> <span class='ident'>display</span>.<span class='ident'>draw</span>();
<span class='ident'>target</span>.<span class='ident'>clear_color</span>(<span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span>, <span class='number'>0.0</span>);  <span class='comment'>// filling the output with the black color</span>
<span class='ident'>target</span>.<span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='ident'>vertex_buffer</span>, <span class='kw-2'>&amp;</span><span class='ident'>index_buffer</span>, <span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='kw-2'>&amp;</span><span class='ident'>uniforms</span>, <span class='kw-2'>&amp;</span><span class='ident'>std</span>::<span class='ident'>default</span>::<span class='ident'>Default</span>::<span class='ident'>default</span>());
<span class='ident'>target</span>.<span class='ident'>finish</span>();
</pre>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use index_buffer::<a class='struct' href='../glium/index_buffer/struct.IndexBuffer.html' title='glium::index_buffer::IndexBuffer'>IndexBuffer</a>;</code></td></tr><tr><td><code>pub use vertex_buffer::{<a class='struct' href='../glium/vertex_buffer/struct.VertexBuffer.html' title='glium::vertex_buffer::VertexBuffer'>VertexBuffer</a>, <a class='trait' href='../glium/vertex_buffer/trait.Vertex.html' title='glium::vertex_buffer::Vertex'>Vertex</a>, <a class='type' href='../glium/vertex_buffer/type.VertexFormat.html' title='glium::vertex_buffer::VertexFormat'>VertexFormat</a>};</code></td></tr><tr><td><code>pub use program::ProgramCreationError::{<a class='enum' href='../glium/enum.ProgramCreationError.html' title='glium::ProgramCreationError'>CompilationError</a>, <a class='enum' href='../glium/enum.ProgramCreationError.html' title='glium::ProgramCreationError'>LinkingError</a>, <a class='enum' href='../glium/enum.ProgramCreationError.html' title='glium::ProgramCreationError'>ShaderTypeNotSupported</a>};</code></td></tr><tr><td><code>pub use texture::{<a class='trait' href='../glium/texture/trait.Texture.html' title='glium::texture::Texture'>Texture</a>, <a class='struct' href='../glium/texture/struct.Texture2d.html' title='glium::texture::Texture2d'>Texture2d</a>};</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='debug/index.html'
                               title='glium::debug'>debug</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='framebuffer/index.html'
                               title='glium::framebuffer'>framebuffer</a></td>
                        <td class='docblock short'><p>Framebuffers allows you to customize the color, depth and stencil buffers you will draw on.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='index_buffer/index.html'
                               title='glium::index_buffer'>index_buffer</a></td>
                        <td class='docblock short'><p>In order to draw, you need to provide a source of indices which is used to link the vertices
together into <em>primitives</em>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='pixel_buffer/index.html'
                               title='glium::pixel_buffer'>pixel_buffer</a></td>
                        <td class='docblock short'><p>Pixel buffers are buffer that contain two-dimensional texture data.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='render_buffer/index.html'
                               title='glium::render_buffer'>render_buffer</a></td>
                        <td class='docblock short'><p>A render buffer is similar to a texture, but is optimized for usage as a draw target.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='texture/index.html'
                               title='glium::texture'>texture</a></td>
                        <td class='docblock short'><p>A texture is an image loaded in video memory and that can be sampled in your shaders.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='uniforms/index.html'
                               title='glium::uniforms'>uniforms</a></td>
                        <td class='docblock short'><p>A uniform is a global variable in your program. In order to draw something, you will need to
 tell <code>glium</code> what the values of all your uniforms are. Objects that implement the <code>Uniform</code>
 trait are here to do that.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='vertex_buffer/index.html'
                               title='glium::vertex_buffer'>vertex_buffer</a></td>
                        <td class='docblock short'><p>Contains everything related to vertex buffers.</p>
</td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Display.html'
                               title='glium::Display'>Display</a></td>
                        <td class='docblock short'><p>The main object of this library. Controls the whole display.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.DrawParameters.html'
                               title='glium::DrawParameters'>DrawParameters</a></td>
                        <td class='docblock short'><p>Represents the parameters to use when drawing.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Frame.html'
                               title='glium::Frame'>Frame</a></td>
                        <td class='docblock short'><p>Implementation of <code>Surface</code> targetting the default framebuffer.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Program.html'
                               title='glium::Program'>Program</a></td>
                        <td class='docblock short'><p>A combinaison of shaders linked together.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Rect.html'
                               title='glium::Rect'>Rect</a></td>
                        <td class='docblock short'><p>Area of a surface in pixels.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.BackfaceCullingMode.html'
                               title='glium::BackfaceCullingMode'>BackfaceCullingMode</a></td>
                        <td class='docblock short'><p>Describes how triangles should be filtered before the fragment processing. Backface culling
is purely an optimization. If you don&#39;t know what this does, just use <code>CullingDisabled</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.BlendingFunction.html'
                               title='glium::BlendingFunction'>BlendingFunction</a></td>
                        <td class='docblock short'><p>Function that the GPU will use for blending.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.DepthFunction.html'
                               title='glium::DepthFunction'>DepthFunction</a></td>
                        <td class='docblock short'><p>The function that the GPU will use to determine whether to write over an existing pixel
on the target.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.GliumCreationError.html'
                               title='glium::GliumCreationError'>GliumCreationError</a></td>
                        <td class='docblock short'><p>Error that can happen while creating a glium display.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.PolygonMode.html'
                               title='glium::PolygonMode'>PolygonMode</a></td>
                        <td class='docblock short'><p>Defines how the device should render polygons.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.ProgramCreationError.html'
                               title='glium::ProgramCreationError'>ProgramCreationError</a></td>
                        <td class='docblock short'><p>Error that can be triggered when creating a <code>Program</code>.</p>
</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='trait' href='trait.DisplayBuild.html'
                               title='glium::DisplayBuild'>DisplayBuild</a></td>
                        <td class='docblock short'><p>Objects that can build a <code>Display</code> object.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='trait' href='trait.Surface.html'
                               title='glium::Surface'>Surface</a></td>
                        <td class='docblock short'><p>Object which can be drawn upon.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "glium";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>